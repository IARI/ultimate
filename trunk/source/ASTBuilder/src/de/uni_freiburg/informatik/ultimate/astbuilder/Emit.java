/*
 * Copyright (C) 2014-2015 Daniel Dietsch (dietsch@informatik.uni-freiburg.de)
 * Copyright (C) 2015 University of Freiburg
 * 
 * This file is part of the ULTIMATE ASTBuilder plug-in.
 * 
 * The ULTIMATE ASTBuilder plug-in is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * The ULTIMATE ASTBuilder plug-in is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with the ULTIMATE ASTBuilder plug-in. If not, see <http://www.gnu.org/licenses/>.
 * 
 * Additional permission under GNU GPL version 3 section 7:
 * If you modify the ULTIMATE ASTBuilder plug-in, or any covered work, by linking
 * or combining it with Eclipse RCP (or a modified version of Eclipse RCP),
 * containing parts covered by the terms of the Eclipse Public License, the
 * licensors of the ULTIMATE ASTBuilder plug-in grant you additional permission
 * to convey the resulting work.
 */
package de.uni_freiburg.informatik.ultimate.astbuilder;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;

public class Emit {
	private static final List<String> BOOL_PREFIXES = Arrays.asList("is", "has");

	protected PrintWriter mWriter;
	protected Grammar mGrammar;
	protected HashSet<String> mEnumTypes;

	public Emit() {
		mEnumTypes = new HashSet<>();
	}

	public void setGrammar(final Grammar grammar) {
		mGrammar = grammar;
	}

	public static String capitalize(final String str) {
		return Character.toTitleCase(str.charAt(0)) + str.substring(1);
	}

	public static String uncapitalize(final String str) {
		return Character.toLowerCase(str.charAt(0)) + str.substring(1);
	}

	public static String breakWords(final String str) {
		final StringBuffer sb = new StringBuffer();
		final int len = str.length();
		for (int i = 0; i < len; i++) {
			final char c = str.charAt(i);
			if (Character.isUpperCase(c) || Character.isTitleCase(c)) {
				if (i > 0) {
					sb.append(' ');
				}
				sb.append(Character.toLowerCase(c));
			} else {
				sb.append(c);
			}
		}
		return sb.toString();
	}

	public static String buildFieldComment(final String className, final String name, final String type) {
		if (type.equals("boolean") && name.length() >= 3 && name.startsWith("is")
				&& (Character.isUpperCase(name.charAt(2)) || Character.isTitleCase(name.charAt(2)))) {
			return "True iff this " + breakWords(className) + " " + breakWords(name) + ".";
		}
		return "The " + breakWords(name) + " of this " + breakWords(className) + ".";
	}

	public static String buildClassComment(final String name, final String parent) {
		final StringBuffer sb = new StringBuffer("Represents a ");
		sb.append(breakWords(name));
		if (parent != null) {
			sb.append(" which is a special form of a ").append(Emit.breakWords(parent));
		}
		sb.append('.');
		return sb.toString();
	}

	private static String getShortComment(final String comment) {
		int end = comment.indexOf('.') + 1;
		if (end == 0) {
			end = comment.length();
		}
		return comment.substring(0, end);
	}

	protected static void formatComment(final PrintWriter writer, final String indent, String comment) {
		writer.println(indent + "/**");
		int nl = comment.indexOf('\n');
		while (nl >= 0) {
			writer.println(indent + " * " + comment.substring(0, nl));
			comment = comment.substring(nl + 1);
			nl = comment.indexOf('\n');
		}
		writer.println(indent + " * " + comment);
		writer.println(indent + " */");
	}

	public void emitClasses() throws IOException {
		for (final Node n : mGrammar.getNodeTable().values()) {
			final String name = n.getName();
			System.err.println("Building: " + name);
			mWriter = new PrintWriter(new FileWriter(name + ".java"));
			emitNode(n);
			mWriter.close();
			mWriter = null;
		}
	}

	public void emitPreamble(final Node node) throws IOException {
		final String name = node.getName();
		mWriter.println("/* " + name + " -- Automatically generated by TreeBuilder */");
		mWriter.println();
		final String pkgName = mGrammar.getPackageName();
		if (pkgName.length() > 0) {
			mWriter.println("package " + pkgName + ";");
		}
		for (final String importStr : mGrammar.getImports()) {
			if (!importStr.endsWith(".*")) {
				boolean found = false;
				Node ancestor = node;
				while (!found && ancestor != null) {
					/* Check if type is used */
					final int dotIndex = importStr.lastIndexOf('.');
					final String type = importStr.substring(dotIndex + 1);
					if (ancestor.getUsedTypes().contains(type)) {
						found = true;
					}
					ancestor = ancestor.getParent();
				}
				if (!found) {
					continue;
				}
			}
			mWriter.println("import " + importStr + ";");
		}
		mWriter.println();
	}

	public void emitClassDeclaration(final Node node) throws IOException {
		mWriter.println("public " + (node.isAbstract() ? "abstract " : "") + "class " + node.getName()
				+ (node.getParent() != null ? " extends " + node.getParent().getName() : "")
				+ (node.getInterfaces() != null ? " implements " + node.getInterfaces() : "") + " {");
	}

	public String getConstructorParam(final Node node, final boolean optional) {
		if (node == null) {
			return "";
		}

		final StringBuffer sb = new StringBuffer();

		sb.append(getConstructorParam(node.getParent(), optional));

		String comma = "";
		if (sb.length() > 0) {
			comma = ", ";
		}

		for (final Parameter parameter : node.getParameters()) {
			if (optional || !parameter.isOptional()) {
				final String pname = parameter.getName();
				sb.append(comma).append(pname);
				comma = ", ";
			}
		}
		return sb.toString();
	}

	public String getRootConstructorParam(final Node node, final boolean optional) {
		return "";
	}

	protected void fillConstructorParamComment(final Node node, final StringBuffer param, final StringBuffer comment,
			final boolean optional) {
		final Node parent = node.getParent();
		if (parent != null) {
			fillConstructorParamComment(parent, param, comment, optional);
		}
		String comma = "";
		if (param.length() > 0) {
			comma = ", ";
		}
		for (final Parameter parameter : node.getParameters()) {
			if (optional || !parameter.isOptional()) {
				final String pname = parameter.getName();
				final String pcomment = uncapitalize(getShortComment(parameter.getComment()));
				comment.append("\n@param ").append(pname).append(' ').append(pcomment);
				param.append(comma);
				param.append(parameter.getType()).append(' ').append(pname);
				comma = ", ";
			}
		}
	}

	public void emitConstructor(final Node node, final boolean optional) throws IOException {
		final String name = node.getName();
		final String parentParams;
		if (node.getParent() == null) {
			parentParams = getRootConstructorParam(node, optional);
		} else {
			parentParams = getConstructorParam(node.getParent(), optional);
		}

		final StringBuffer constructorParams = new StringBuffer();
		final StringBuffer constructorComment = new StringBuffer("The constructor taking initial values.");
		fillConstructorParamComment(node, constructorParams, constructorComment, optional);
		formatComment(mWriter, "    ", constructorComment.toString());

		mWriter.println("    public " + name + "(" + constructorParams.toString() + ") {");
		if (parentParams != null) {
			mWriter.println("        super(" + parentParams + ");");
		}
		for (final Parameter parameter : node.getParameters()) {
			if (optional || !parameter.isOptional()) {
				final String pname = parameter.getName();
				mWriter.println("        this." + pname + " = " + pname + ";");
			}
		}
		emitConstructorAfterParamAssign(node, optional);
		mWriter.println("    }");
		mWriter.println();
	}

	public void emitConstructorAfterParamAssign(final Node node, final boolean optional) throws IOException {
		// do nothing per default
	}

	public void emitConstructors(final Node node) throws IOException {
		if (node == null) {
			throw new IllegalArgumentException();
		}
		int numNotWriteableParams = 0;
		int numNotOptionalParams = 0;
		int numTotalParams = 0;

		/* Default constructor is only emitted if all fields are writeable */
		/* Optional constructor is only emitted if there are optional fields */
		Node ancestor = node;
		while (ancestor != null) {
			for (final Parameter p : ancestor.parameters) {
				numTotalParams++;
				if (!p.isWriteable()) {
					numNotWriteableParams++;
				}
				if (!p.isOptional()) {
					numNotOptionalParams++;
				}
			}
			ancestor = ancestor.getParent();
		}
		if (numNotOptionalParams == 0 || numNotWriteableParams == 0) {
			formatComment(mWriter, "    ", "The default constructor.");
			mWriter.println("    public " + node.getName() + "() {");
			mWriter.println("    }");
			mWriter.println();
		}

		if (numNotOptionalParams > 0 && numNotOptionalParams < numTotalParams) {
			emitConstructor(node, false);
		}
		if (numTotalParams > 0) {
			emitConstructor(node, true);
		}
	}

	void emitArrayToStringCode(String name, String type, final String indent, final int level) {
		final String ivar = "i" + level;
		type = type.substring(0, type.length() - 2);
		final String newindent = indent + "        ";
		mWriter.println(indent + "if (" + name + " == null) {");
		mWriter.println(indent + "    sb.append(\"null\");");
		mWriter.println(indent + "} else {");
		mWriter.println(indent + "    sb.append('[');");
		mWriter.println(indent + "    for(int " + ivar + " = 0; " + ivar + " < " + name + ".length; " + ivar + "++) {");
		mWriter.println(newindent + "if (" + ivar + " > 0) sb.append(',');");
		name += "[" + ivar + "]";
		if (type.endsWith("[]")) {
			emitArrayToStringCode(name, type, newindent, level + 1);
		} else {
			mWriter.println(newindent + "    sb.append(" + name + ");");
		}
		mWriter.println(indent + "    }");
		mWriter.println(indent + "    sb.append(']');");
		mWriter.println(indent + "}");
	}

	public void emitNodeHook(final Node node) throws IOException {
		// can be overriden by subclasses that want to implement a node hook
	}

	public void emitNode(final Node node) throws IOException {
		final String name = node.getName();
		final Parameter[] parameters = node.getParameters();

		emitPreamble(node);

		formatComment(mWriter, "", node.getComment());
		emitClassDeclaration(node);

		if (parameters != null && parameters.length > 0) {
			/* collect enum types */
			for (int i = 0; i < parameters.length; i++) {
				String ptype = parameters[i].getType();
				if (ptype.startsWith("!")) {
					/* java 1.5 enum types */
					int nextComma = ptype.indexOf(',', 1);
					if (nextComma == -1) {
						nextComma = ptype.length();
					}
					final String enumName = ptype.substring(1, nextComma);
					mWriter.println("    public enum " + enumName + " {");
					StringBuilder sb = new StringBuilder();
					sb.append("        ");
					String comma = "";
					ptype = ptype.substring(nextComma);
					while (ptype.length() > 0) {
						nextComma = ptype.indexOf(',', 1);
						if (nextComma == -1) {
							nextComma = ptype.length();
						}
						sb.append(comma);
						if (sb.length() + nextComma > 80) {
							mWriter.println(sb.toString());
							sb = new StringBuilder();
							sb.append("        ");
						}
						sb.append(ptype.substring(1, nextComma));
						comma = ", ";
						ptype = ptype.substring(nextComma);
					}
					mWriter.println(sb.toString());
					mWriter.println("    }");
					mWriter.println();
					parameters[i].setType(enumName);
					mEnumTypes.add(enumName);
				} else if (ptype.startsWith(",")) {
					int idx = 0;
					while (ptype.length() > 0) {
						int nextComma = ptype.indexOf(',', 1);
						if (nextComma == -1) {
							nextComma = ptype.length();
						}
						final String enumeration = ptype.substring(1, nextComma);
						mWriter.println("    public final static int " + enumeration + " = " + idx++ + ";");
						ptype = ptype.substring(nextComma);
					}
					mWriter.println();
					parameters[i].setType("int");
				}
			}

			for (int i = 0; i < parameters.length; i++) {
				formatComment(mWriter, "    ", parameters[i].getComment());
				mWriter.println("    " + parameters[i].getType() + " " + parameters[i].getName() + ";");
				mWriter.println();
			}
		}

		emitConstructors(node);

		final String toStringComment = "Returns a textual description of this object.";
		formatComment(mWriter, "    ", toStringComment);
		mWriter.println("    public String toString() {");
		if (parameters != null && parameters.length > 0) {
			mWriter.println("        StringBuffer sb = new StringBuffer();");
			mWriter.println("        sb.append(\"" + name + "\").append('[');");
			String comma = "";
			for (int i = 0; i < parameters.length; i++) {
				final String pname = parameters[i].getName();
				final String ptype = parameters[i].getType();
				if (ptype.endsWith("[]")) {
					if (!"".equals(comma)) {
						mWriter.println("        sb" + comma + ";");
					}
					emitArrayToStringCode(pname, ptype, "        ", 1);
				} else {
					mWriter.println("        sb" + comma + ".append(" + pname + ");");
				}
				comma = ".append(',')";
			}
			mWriter.println("        return sb.append(']').toString();");
		} else {
			mWriter.println("        return \"" + name + "\";");
		}
		mWriter.println("    }");

		if (parameters != null && parameters.length > 0) {
			for (int i = 0; i < parameters.length; i++) {
				mWriter.println();

				final String pname = parameters[i].getName();
				final String ptype = parameters[i].getType();
				final String pcomment = parameters[i].getComment();
				final String cpname = capitalize(pname);
				String getName = "get" + cpname;
				String setName = "set" + cpname;
				String getComment;
				String setComment;
				if (ptype.equals("boolean")) {
					int j = 0;
					for (final String prefix : BOOL_PREFIXES) {
						if (pname.startsWith(prefix)) {
							j = prefix.length();
							break;
						}
					}
					if (j > 0) {
						getName = pname;
						setName = "set" + pname.substring(j);
					}
					String nonTrueComment = pcomment;
					if (nonTrueComment.startsWith("True ")) {
						nonTrueComment = nonTrueComment.substring(5);
					}
					getComment = "Checks " + uncapitalize(nonTrueComment) + "\n@return "
							+ uncapitalize(getShortComment(pcomment));
					setComment = "Sets " + uncapitalize(nonTrueComment) + "\n@param " + pname + " "
							+ uncapitalize(getShortComment(pcomment));
				} else {
					getComment =
							"Gets " + uncapitalize(pcomment) + "\n@return " + uncapitalize(getShortComment(pcomment));
					setComment = "Sets " + uncapitalize(pcomment) + "\n@param " + pname + " "
							+ uncapitalize(getShortComment(pcomment));
				}
				formatComment(mWriter, "    ", getComment);
				mWriter.println("    public " + ptype + " " + getName + "() {");
				mWriter.println("        return " + pname + ";");
				mWriter.println("    }");

				if (parameters[i].isWriteable()) {
					mWriter.println();
					formatComment(mWriter, "    ", setComment);
					mWriter.println("    public void " + setName + "(" + ptype + " " + pname + ") {");
					if (parameters[i].isWriteableOnce) {
						mWriter.println("        //Writeable only once");
						mWriter.println(
								"        if(this." + pname + " != null && " + pname + " != this." + pname + "){");
						mWriter.println("                throw new AssertionError(\"Value is only writeable once\");");
						mWriter.println("        }");
					}
					mWriter.println("        this." + pname + " = " + pname + ";");
					mWriter.println("    }");
				}
			}
		}
		emitNodeHook(node);
		mWriter.println("}");
		mWriter.close();
	}

}
